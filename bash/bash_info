============
Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется
истинным и выполнение не пойдёт по ветке else. В противном случае, если будет возвращено что-то,
отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды,
расположенные после else.
0 - ok
!0 - not ok

===========
Сравнение чисел
В скриптах можно сравнивать числовые значения. Ниже приведён список соответствующих команд.
n1 -eq n2 Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1 больше или равно n2.
n1 -gt n2 Возвращает истинное значение, если n1 больше n2.
n1 -le n2 Возвращает истинное значение, если n1 меньше или равно n2.
n1 -lt n2 Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2 Возвращает истинное значение, если n1 не равно n2.

Обратите внимание на то, что
выражение заключено в квадратные скобки.

echo "your choise $1"
nn=$1
echo "nn $nn"
if [ $nn -gt 10 ]
then
var2=$(($1+$1))
echo $var2
else
echo "try one more"
fi
===========

Сравнение строк
str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2 Возвращает истину, если строки не идентичны.
str1 < str2 Возвращает истину, если str1 меньше, чем str2.
str1 > str2 Возвращает истину, если str1 больше, чем str2.
-n str1 Возвращает истину, если длина str1 больше нуля.
-z str1 Возвращает истину, если длина str1 равна нулю.

Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<»
необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать
неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду
перенаправления вывода.

В командах сравнения прописные буквы меньше строчных. Сравнение строк здесь выполняется путём
сравнения ASCII-кодов символов, порядок сортировки, таким образом, зависит от кодов символов.
Команда sort, в свою очередь, использует порядок сортировки, заданный в настройках системного
языка

!заключать переменные в кавычки: 

if [ "$val1" != "$val2" ]
then
echo "vvvvv $val1"
else
echo "--- $val2"
fi
================

Проверки файлов

-d file Проверяет, существует ли файл, и является ли он директорией.
-e file Проверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r file Проверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w file Проверяет, существует ли файл, и доступен ли он для записи.
-x file Проверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2 Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G file Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору
группы текущего пользователя.

================

Цикл for

for var in list
do
команды
done
В каждой итерации цикла в переменную var будет записываться следующее значение из списка list. В
первом проходе цикла, таким образом, будет задействовано первое значение из списка. Во втором —
второе, и так далее — до тех пор, пока цикл не дойдёт до последнего элемента.

#read all worlds from file and print each in separate line

file="tfile"
for var in $(cat $file)
do
echo " $var"
done

all worlds from file are printed each in separate line
Причина вышеописанной особенности заключается в специальной переменной окружения, которая
называется IFS (Internal Field Separator) и позволяет указывать разделители полей. По умолчанию
оболочка bash считает разделителями полей следующие символы:
Пробел
Знак табуляции
Знак перевода строки

Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее
самостоятельное значение списка.
Для того, чтобы решить проблему, можно временно изменить переменную среды IFS. Вот как это
сделать в bash-скрипте, если исходить из предположения, что в качестве разделителя полей нужен
только перевод строки:
IFS=$'\n'


вывести список файлов и папок:
#!/bin/bash
for file in /home/mydir/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done

----------------

перебор от 1 до 10

#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done

===================
Цикл while

#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done

Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается
перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит
обработка файла /etc/passwd:
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done
В этом скрипте два цикла. Первый проходится по строкам, используя в качестве разделителя знак
перевода строки. Внутренний занят разбором строк, поля которых разделены двоеточиями.

Такой подход можно использовать при обработке файлов формата CSV, или любых подобных файлов,
записывая, по мере надобности, в переменную окружения IFS символ-разделитель
========================
Команда break

do
if [ $var1 -eq 5 ]
then
break
fi

. Например, если
надо выяснить, какие именно исполняемые файлы доступны в системе, можно просканировать все
папки, записанные в переменную окружения PATH

#!/bin/bash
IFS=:
for folder in $PATH
do
echo "$folder:"
for file in $folder/*
do
if [ -x $file ]
then
echo " $file"
fi
done
done
Такой вот скрипт, небольшой и несложный, позволил получить список исполняемых файлов,
хранящихся в папках из PATH.

==================
Чтение параметров командной строки
$0 — имя скрипта.
$1 — первый параметр.
$2 — второй параметр — и так далее, вплоть до переменной $9, в которую попадает девятый
параметр.

Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо
заключать в фигурные скобки, например так:
${10}
----------------
Проверка параметров
Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие,
возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных
сценарию при вызове. Например, это можно организовать так:

#!/bin/bash
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
==============

Подсчёт параметров
В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет
для этого специальную переменную. А именно, переменная $# содержит количество параметров,
переданных сценарию при вызове. Опробуем её:
#!/bin/bash
echo There were $# parameters passed.
-------
Эта переменная даёт необычный способ получения последнего из переданных скрипту параметров, не
требующий знания их количества. Вот как это выглядит:
#!/bin/bash
echo The last parameter was ${!#}

Переменная $* содержит все параметры, введённые в командной строке, в виде единого «слова».
В переменной $@ параметры разбиты на отдельные «слова». Эти параметры можно перебирать в
циклах.
=============


Ключи командной строки
Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для
управления сценариями.

#!/bin/bash
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
=============

различать ключи и параметры

двойное тире (--). Оболочка использует её для указания позиции, на
которой заканчивается список ключей.

-----
Обработка ключей со значениями

./myscript -a -b test1 -d


#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option";;
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
-c) echo "Found the -c option";;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in "$@"
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
============

Получение данных от пользователя


read команда позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры), либо
используя другие дескрипторы файлов. После получения данных, эта команда помещает их в
переменную:
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."

echo -n приводит к тому, что в конце приглашения не выводится знак перевода строки, что позволяет
пользователю скрипта вводить данные там же, где расположено приглашение, а не на следующей
строке.
===----------
При вызове read можно указывать и несколько переменных:
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first..."
-----------
Если, вызвав read, не указывать переменную, данные, введённые пользователем, будут помещены в
специальную переменную среды REPLY:
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
-----------
сли скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то
данные или нет, вызывая команду read можно воспользоваться ключом -t. А именно, параметр ключа
задаёт время ожидания ввода в секундах:
#!/bin/bash
if read -t 5 -p "Enter your name: " name
then
echo "Hello $name, welcome to my script"
else
echo "Sorry, too slow! "
fi
Если данные не будут введены в течение 5 секунд, скрипт выполнит ветвь условного оператора else,
выведя извинения.

-----------
Ввод паролей

Ключ -s команды read предотвращает отображение
на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда read делает
цвет текста таким же, как цвет фона.
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "

=============

Чтение данных из файла

Команда read может, при каждом вызове, читать одну строку текста из файла.

#!/bin/bash
count=1
cat myfile | while read line
do
echo "Line $count: $line"
count=$(( $count + 1 ))
done
echo "Finished"
=====================

Перенаправление потоков ошибок и вывода
ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
&> Если надо, и STDERR, и STDOUT можно перенаправить в один и тот же файл

можно задать перенаправление вывода в
определённый дескриптор на время выполнения скрипта, воспользовавшись командой exec:
#!/bin/bash
exec 1>outfile
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"

= запись в файл outfile

==============
Перенаправление ввода в скриптах


exec 0< myfile
Эта команда указывает оболочке на то, что источником вводимых данных должен стать файл myfile, а
не обычный STDIN. Посмотрим на перенаправление ввода в действии:
#!/bin/bash
exec 0< testfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
===============
Файловий дескриптор — абстрактний показник для доступу до файлу в операційних системах.

Назначить дескриптор для вывода данных можно, используя команду exec:
#!/bin/bash
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
После запуска скрипта часть вывода попадёт на экран, часть — в файл с дескриптором 3

=================

Перехват сигналов

Команда trap позволяет скрипту реагировать на сигналы, в противном случае их обработка
выполняется оболочкой без его участия.
Рассмотрим пример, в котором показано, как при вызове команды trap задаётся код, который надо
выполнить, и список сигналов, разделённых пробелами, которые мы хотим перехватить. В данном
случае это всего один сигнал:
#!/bin/bash
trap "echo ' Trapped Ctrl-C'" SIGINT
echo This is a test script
count=1
while [ $count -le 10 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done

Команда trap, использованная в этом примере, выводит текстовое сообщение всякий раз, когда она
обнаруживает сигнал SIGINT, который можно сгенерировать, нажав Ctrl + C на клавиатуре.

==============

Выполнение скриптов, не завершающих работу при закрытии
терминала

Скрипты можно выполнять в фоновых процессах даже после выхода из терминальной сессии. Для
этого можно воспользоваться командой nohup. Эта команда позволяет запустить программу, блокируя
сигналы SIGHUP, отправляемые процессу.

nohup ./myscript &

nohup отвязывает процесс от терминала. Это означает, что процесс потеряет ссылки на
STDOUT и STDERR. Для того, чтобы не потерять данные, выводимые скриптом, nohup автоматически
перенаправляет сообщения, поступающие в STDOUT и в STDERR, в файл nohup.out.
Обратите внимание на то, что при запуске нескольких скриптов из одной и той же директории то, что
они выводят, попадёт в один файл nohup.out.
=============

Глобальные переменные — это переменные, которые видны из любого места bash-скрипта

По умолчанию все объявленные в скриптах переменные глобальны. Так, к переменным, объявленным
за пределами функций, можно без проблем обращаться из функций:
#!/bin/bash
function myfunc {
value=$(( $value + 10 ))
}
read -p "Enter a value: " value
myfunc
echo "The new value is: $value"
=================
Локальные переменные
Переменные, которые объявляют и используют внутри функции, могут быть объявлены локальными.
Для того, чтобы это сделать, используется ключевое слово local перед именем переменной:
local temp=$(( $value + 5 ))
================
Создание и использование библиотек


Ключ к использованию библиотек — в команде source. Эта команда используется для подключения
библиотек к скриптам. В результате функции, объявленные в библиотеке, становятся доступными в
скрипте, в противном же случае функции из библиотек не будут доступны в области видимости других
скриптов.
У команды source есть псевдоним — оператор «точка». Для того, чтобы подключить файл в скрипте, в
скрипт надо добавить конструкцию такого вида:
. ./myscrip


