expect

expect [-dDinNv] [-c <список_команд>] [ [-[f|b]] <файл_скрипта>] [<аргументы>]

Флаг -d активизирует вывод некоторой диагностической информации, в основном касающейся выполнения внутренних операций команд, таких как expect и interact.

Флаг -D активизирует интерактивный отладчик. Более подробно о работе отладчика можно узнать из документации.

Флаг -i переводит Expect в интерактивный режим, в котором ожидается ввод команд с клавиатуры, а не из файла скрипта.

Флаги -n и -N отключают использование файлов ресурсов. Если существует файл $exp_library/expect.rc, то данные из него считываются автоматически при условии, что не задан флаг -N. Сразу после этого автоматически считываются данные из файла ~/.expect.rc при условии, что не задан флаг -n.

Флаг -c предваряет команду или список команд, которые должны быть выполнены до того, как начнётся выполнение команд скрипта. В списке команды отделяются друг от друга точкой с запятой. Команду или список команд необходимо записывать в кавычках, чтобы защитить их от воздействия командной оболочки.

После флага -f записывается имя файла скрипта, из которого будут считываться команды.

По умолчанию весь файл скрипта считывается в память перед выполнением. Но иногда необходимо, чтобы выполнялось построчное чтение, например, для работы с устройством стандартного ввода. Чтобы установить такой режим считывания, воспользуйтесь флагом -b.

Из форматной записи очевидно, что флаги -f и -b являются взаимоисключающими и не обязательными. Иными словами, если встречается только символ "-", то Expect будет считывать команды из стандартного устройства ввода stdin (как правило, это клавиатура).

Флаг -v выводит номер текущей версии и завершает работу программы.

В конце строки могут быть записаны аргументы, передаваемые в скрипт. Эти аргументы сохраняются в форме списка в переменной argv. Переменная argc инициализируется числовым значением, соответствующим длине списка argv.

Как и для любого скриптового языка в Unix-системах, если в первой строке файла, содержащего команды Expect, записать строку идентификации:

	
#!/usr/bin/expect -f

и установить для него статус "выполняемый" 



Expect позволяет создавать программы, ожидающие вопросов от других программ и дающие им
ответы. Expect можно сравнить с роботом, который способен заменить пользователя при
взаимодействии со сценариями командной строки.

spawn — запуск процесса или программы. Например, это может быть командная оболочка, FTP,
Telnet, ssh, scp и так далее.
expect — ожидание данных, выводимых программой. При написании скрипта можно указать, какого
именно вывода он ждёт и как на него нужно реагировать.
send — отправка ответа. Expect-скрипт с помощью этой команды может отправлять входные
данные автоматизируемой программе. Она похожа на знакомую вам команду echo в обычных bash-
скриптах.
interact — позволяет переключиться на «ручной» режим управления программой.


Напишем скрипт, который взаимодействует с пользователем и автоматизируем его с помощью expect.
Вот код bash-скрипта questions:
#!/bin/bash
echo "Hello, who are you?"
read $REPLY
echo "Can I ask you some questions?"
read $REPLY
echo "What is your favorite topic?"
136read $REPLY

Теперь напишем expect-скрипт, который запустит скрипт questions и будет отвечать на его вопросы:
#!/usr/bin/expect -f
set timeout -1
spawn ./questions
expect "Hello, who are you?\r"
send -- "Im Adam\r"
expect "Can I ask you some questions?\r"
send -- "Sure\r"
expect "What is your favorite topic?\r"
send -- "Technology\r"
expect eof

========

Для объявления переменных в expect-скриптах используется команда set. Например, для того, чтобы
присвоить значение 5 переменной VAR1, используется следующая конструкция:
set VAR1 5

Для доступа к значению переменной перед её именем надо добавить знак доллара — $. В нашем
случае это будет выглядеть как $VAR1.
Для того, чтобы получить доступ к аргументам командной строки, с которыми вызван expect-скрипт,
можно поступить так:
set VAR [lindex $argv 0]
Тут мы объявляем переменную VAR и записываем в неё указатель на первый аргумент командной
строки, $argv 0.
=======

Если автоматизируемая программа может, в одной ситуации, выдать одну строку, а в другой, в том же
самом месте — другую, в expect можно использовать блоки, заключённые в фигурные скобки и
содержащие варианты реакции скрипта на разные данные, полученные от программы. Выглядит это
так:
expect {
"something" { send -- "send this\r" }
"*another" { send -- "send another\r" }
}
========
