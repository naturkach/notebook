!они чувствительны к регистру символов
-------------

^ - начало строки 
$ - конец строки
. - Точка используется для поиска любого одиночного символа, за исключением символа перевода строки.
[oi]  набор  о или і
[^oi] отрицание ни о ни і
[e-p] диапазон
* - регулярное выражение сработает, если символ появляется в строке любое количество раз — включая и ситуацию, когда символ в строке отсутствует.
.* - любое количество любых символов
? предшествующий символ может встретиться в тексте один раз или не встретиться вовсе.
+ предшествующий символ должен встречаться 1 или более раз
{} - задают количество вхождений предыдущего символа
 {n} — число, задающее точное число искомых вхождений
 {n, m} — два числа, которые трактуются так: «как минимум n раз, но не больше чем m».
| - «или»
() - Группировка фрагментов -, она будет восприниматься системой как обычный символ. То есть, например, к ней можно будет применить метасимволы повторений
(a|b) a или b

\ -  экранирующий символ
\A - начало текста
\Z - конец текста
\b - граница слова
\< - начало слова
\> - конец слова
\s - пробел
\w - слово
?()- если то
([A-Za-z0-9]+) буквы числа и знаки переноса
(\d{1,2}\/\d{1,2}\/\d{4}) дата напр 27/10/2020
(\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,6}) E-mail
(\<(/?[^\>]+)\>)  html теги

====================

поиск строки по шаблону

$ echo "This is a test" | sed -n '/test/p'
$ echo "This is a test" | awk '/test/{print $0}'


sed -n '/numb/p' year.py
        numb = int(year[1]) + 1
        print(year[0] + str(numb))

----------------------------

Специальные символы
При использовании различных символов в регулярных выражениях надо учитывать некоторые
особенности. Так, существуют некоторые специальные символы, или метасимволы, использование
которых в шаблоне требует особого подхода. Вот они:
.*[]^${}\+?|()
Если один из них нужен в шаблоне, его нужно будет экранировать с помощью обратной косой черты
(обратного слэша) — \.
Например, если в тексте нужно найти знак доллара, его надо включить в шаблон, предварив символом
экранирования. Скажем, имеется файл myfile с таким текстом:
There is 10$ on my pocket
Знак доллара можно обнаружить с помощью такого шаблона:
$ awk '/\$/{print $0}' myfile
-------------------------

отфильтровать пустые строки:
$ awk '!/^$/{print $0}' myfile
В данном шаблоне использовал символ отрицания, восклицательный знак — !. Благодаря
использованию такого шаблона выполняется поиск строк, не содержащих ничего между началом и
концом строки, а благодаря восклицательному знаку на печать выводятся лишь строки, которые не
соответствуют этому шаблону.

поиск всех строк где есть шаблон .st
$ awk '/.st/{print $0}' myfile

диапазн/набор [oi] о или і
$ awk '/[oi]th/{print $0}' myfile

В данном случае будут найдены последовательности символов «th», перед которыми нет ни «o», ни «i».
$ awk '/[^oi]th/{print $0}' myfile


* 
echo "test" | awk '/tes*t/{print $0}'
еcho "tessst" | awk '/tes*t/{print $0}'

.*
$ awk '/this.*test/{print $0}' myfile


$ echo "tst" | awk
'/t[ae]{1,2}st/{print $0}'
Шаблон отреагирует на текст в том случае, если в нём один или два раза встретится символ «a» или
символ «e».

Специальные классы символов
В BRE имеются специальные классы символов, которые можно использовать при написании
регулярных выражений:
[[:alpha:]] — соответствует любому алфавитному символу, записанному в верхнем или нижнем
регистре.
[[:alnum:]] — соответствует любому алфавитно-цифровому символу, а именно — символам в
диапазонах 0-9, A-Z, a-z.
[[:blank:]] — соответствует пробелу и знаку табуляции.
[[:digit:]] — любой цифровой символ от 0 до 9.
[[:upper:]] — алфавитные символы в верхнем регистре — A-Z.
[[:lower:]] — алфавитные символы в нижнем регистре — a-z.
[[:print:]] — соответствует любому печатаемому символу.
[[:punct:]] — соответствует знакам препинания.
[[:space:]] — пробельные символы, в частности — пробел, знак табуляции, символы NL, FF, VT, CR.
Использовать специальные классы в шаблонах можно так:
$ echo "abc" | awk '/[[:alpha:]]/{print $0}'
$ echo "abc" | awk '/[[:digit:]]/{print $0}'
$ echo "abc123" | awk '/[[:digit:]]/{print $0}'
