SED
----
sed - stream editor for filtering and transforming text
инструмент для обработки строковых данных

иползование: 
 $ sed options file

заменить слово:
 $ echo "This is a test" | sed 's/test/another test/'
Буква «s» — это сокращение слова «substitute», то есть — перед нами команда замены
тоже, передаем на ввод файл:
$ sed 's/test/another test' ./myfile


Для выполнения нескольких действий с данными, используйте ключ -e при вызове sed. Например, вот
как организовать замену двух фрагментов текста:
$ sed -e 's/This/That/; s/test/another test/' ./myfile

Чтение команд из файла
Если имеется множество команд sed, с помощью которых надо обработать текст, обычно удобнее
всего предварительно записать их в файл. Для того, чтобы указать sed файл, содержащий команды,
используют ключ -f:
Вот содержимое файла mycommands:
s/This/That/
s/test/another test/
Вызовем sed, передав редактору файл с командами и файл для обработки:
$ sed -f mycommands myfile

------------
Команда замены нормально обрабатывает файл, состоящий из нескольких строк, но заменяются
только первые вхождения искомого фрагмента текста в каждой строке. Для того, чтобы заменить все
вхождения шаблона, нужно использовать соответствующий флаг.
Схема записи команды замены при использовании флагов выглядит так:
s/pattern/replacement/flags


Выполнение этой команды можно модифицировать несколькими способами:
При передаче номера учитывается порядковый номер вхождения шаблона в строку, заменено
будет именно это вхождение.
Флаг g указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.
Флаг p указывает на то, что нужно вывести содержимое исходной строки.
Флаг вида w file указывает команде на то, что нужно записать результаты обработки текста в файл.
Рассмотрим использование первого варианта команды замены, с указанием позиции заменяемого
вхождения искомого фрагмента:
$ sed 's/test/another test/2' myfile
--------------------
Символы-разделители
Представьте, что нужно заменить /bin/bash на /bin/csh в файле /etc/passwd. Задача не такая уж и
сложная:
$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd
К счастью, sed позволяет нам самостоятельно задавать символы-разделители для использования их в
команде замены. Разделителем считается первый символ, который будет встречен после s:
$ sed 's!/bin/bash!/bin/csh!' /etc/passwd
В данном случае в качестве разделителя использован восклицательный знак, в результате код легче
читать и он выглядит куда опрятнее, чем прежде.
---------------

Выбор фрагментов текста для обработки
обрабатывать только 2-ю строку из файла:
$ sed '2s/test/another test/' myfile

Второй вариант — диапазон строк:
$ sed '2,3s/test/another test/' myfile

Кроме того, можно вызвать команду замены так, чтобы файл был обработан начиная с некоей строки и
до конца:
$ sed '2,$s/test/another test/' myfile

Для того, чтобы обрабатывать с помощью команды замены только строки, соответствующие заданному
фильтру, команду надо вызвать так:
$ sed '/likegeeks/s/bash/csh/' /etc/passwd
------------

Удаление строк

$ sed '3d' myfile
Мы хотим, чтобы из текста была удалена третья строка. Обратите внимание на то, что речь не идёт о
файле. Файл останется неизменным, удаление отразится лишь на выводе, который сформирует sed.

удалить диапазон строк
$ sed '2,3d' myfile

удалить строки, начиная с заданной — и до конца файла:
$ sed '3,$d' myfile 

удалять и по шаблону:
$ sed '/test/d' myfile

$ sed '/second/,/fourth/d' myfile — будут удалены строки, в которых встретится шаблон,
и те строки, которые находятся между ними
-----------


Вставка текста в поток
С помощью sed можно вставлять данные в текстовый поток, используя команды i и a:

Команда i добавляет новую строку перед заданной.
Команда a добавляет новую строку после заданной.
Рассмотрим пример использования команды i:
$ echo "Another test" | sed 'i\First test '
$ echo "Another test" | sed 'a\First test '


вставка внутри потока:
Вызовем команду i, указав номер строки, перед которой надо
вставить новую строку:
$ sed '2i\This is the inserted line.' myfile
-----------

Замена строк
Команда "c" позволяет изменить содержимое целой строки текста в потоке данных. При её вызове нужно
указать номер строки, вместо которой в поток надо добавить новые данные:
$ sed '3c\This is a modified line.' myfile

Если воспользоваться при вызове команды шаблоном в виде обычного текста или регулярного
выражения, заменены будут все соответствующие шаблону строки:
$ sed '/This is/c This is a changed line of text.' myfile

----------
Замена символов
Команда y работает с отдельными символами, заменяя их в соответствии с переданными ей при
вызове данными:
$ sed 'y/123/567/' myfile
1 на 5
2 на 6
3 на 7

=======================================

AWK
gawk - pattern scanning and processing language
язык обработки данных awk

Схема вызова awk выглядит так:
$ awk options program file


awk назначает переменную каждому элементу в строке.
вывод первых элементов всех строк:
$ awk '{print $1}' myfile

Иногда в некоторых файлах в качестве разделителей полей используется что-то, отличающееся от
пробелов или символов табуляции. Выше мы упоминали ключ awk -F, который позволяет задать
необходимый для обработки конкретного файла разделитель:
$ awk -F: '{print $1}' /etc/passwd

Для того, чтобы передать awk многострочную команду при вызове его из консоли, нужно разделить её части точкой с запятой:
$ echo "My name is Tom" | awk '{$4="Adam"; print $0}'



Awk позволяет хранить скрипты в файлах и ссылаться на них, используя ключ -f.
Подготовим файл testfile, в который запишем следующее:
{print $1 " has a
home directory at " $6}
Вызовем awk, указав этот файл в качестве источника команд:
$ awk -F: -f testfile /etc/passwd


Выполнение команд до начала обработки данных
$ awk 'BEGIN {print "The File Contents:"}{print $0}' myfile

Ключевое слово END позволяет задавать команды, которые надо выполнить после окончания
обработки данных:
$ awk 'BEGIN {print "The File Contents:"}
{print $0}
END {print "End of File"}' myfile


Предположим, имеется файл testfile, содержащий такие данные:
1235.9652147.91
927-8.365217.27
36257.8157492.5
Известно, что внутренняя организация этих данных соответствует шаблону 3-5-2-5, то есть, первое
поле имеет ширину 3 символа, второе — 5, и так далее. Вот скрипт, который позволит разобрать такие
записи:
$ awk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' testfile

------------
Переменная NF позволяет обращаться к последнему полю данных в записи, не зная его точной
позиции:
$ awk 'BEGIN{FS=":"; OFS=":"} {print $1,$NF}' /etc/passwd
------------

if-then-else:
$ awk '{if ($1 > 20) print $1}' testfile   = вывод первых чисел каждой стоки больше 20

Цикл while
Цикл while позволяет перебирать наборы данных, проверяя условие, которое остановит цикл.
Вот файл myfile, обработку которого мы хотим организовать с помощью цикла:
124 127 130
112 142 135
175 158 245
Напишем такой скрипт:
$ awk '{
total = 0
i = 1
while (i < 4)
{
total += $i
i++
103}
avg = total / 3
print "Average:",avg
}' testfile
-------------

